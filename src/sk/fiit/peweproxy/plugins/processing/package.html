<html>
<head>
<title>AdaptiveProxy</title>
<body>
Contains interfaces for pluggable processing plugins.
A processing plugins is an external (3rd party) component that decides what to do with a
HTTP message. It's purpose is to decide what information to gather from a message or what
information should the message carry.
<p>
There are two types of processing plugins. <i>Full message processing plugins</i> process entire
HTTPmessages and can decide to switch message being currently processed for another message or
(for requests) make AdaptiveProxy platform to advance in request handling by immediately
constructing responses as if it were received by the web source. <i>Message chunks processing
plugins</i> are processing only chunks of data of messages bodies as they are received from the
source of the message.

Processing plugins can directly read and modify HTTP header of the message being processed, but
can access it's body, if any (full message plugins) / part of the body (chunks plugins) only
indirectly by requesting services present for that message
(see {@link sk.fiit.peweproxy.services.ServicesHandle}) / part of the message
(see {@link sk.fiit.peweproxy.services.ChunkServicesHandle}) and calling their methods.
<p>
Plugins made to be integrated into the handling process of HTTP requests expose classes
implementing {@link sk.fiit.peweproxy.plugins.processing.RequestProcessingPlugin} or
{@link sk.fiit.peweproxy.plugins.processing.RequestChunksProcessingPlugin}
interface. Plugins made to be integrated into the handling process of HTTP responses
expose classes implementing
{@link sk.fiit.peweproxy.plugins.processing.ResponseProcessingPlugin} interface or
{@link sk.fiit.peweproxy.plugins.processing.ResponseChunksProcessingPlugin}.
<p>
For detailed information on setting an order in which AdaptiveProxy will pass HTTP message
being handled to processing plugins, see <a href="doc-files/plugins_ordering">
Plugins ordering file</a>.
<h3><i>Full message processing</i></h3>
<b>Real-time vs. late full message processing</b><br>
Data of the HTTP messages are transfered in chunks of bytes as the source of the message sends
more bytes through the connection with the proxy. The most straightforward implementation of
<i>transparent proxy</i> server (see
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec1.html#sec1.3"> RFC 2616: 1.3
Terminology</a>) reads whole HTTP header first, processes it, and then just transfers (sents
bytes as they are being received) the message body to destination. This is also the fastest
way to successfully proxy a HTTP message. To allow plugins to read and modify <u>whole</u>
message content (header and body data) <u>at once</u>, AdaptiveProxy platform (obviously a
<i>non-transparent proxy</i>) have to cache all incoming data of the message first and just
then run message processing. This means that message destination won't receive any message
data (neither header nor body data) until all plugins successfully processed the message what
slows down overall message exchange. This way the message handling time is increased from
the time it takes the slower node (source or target of the message) to handle (read / write) all
data to time it takes both nodes to handle data together plus time it takes plugins to process
the message.
<p>
This is unavoidable if at least one full message processing plugin wants to modify a message. But
when there's no such plugin, and all full message processing plugins just want to read the
message without modifying it, the platform may use faster data transfer mechanism with caching
data passing through, and then run message processing on cached data. This is where Adaptive
Proxy platform differentiates <i>real-time message processing</i> and <i>late messageprocessing
</i>. 
<p>
<u>Real-time message processing</u> is run every time a message is handled before any data of
the message is sent to destination.
<p>
When no full message processing plugin wants to modify the message body, it's run just after the
message header is received. During this real-time processing, plugins (processing plugins and
modules) are allowed to read and / or change the header, but no services that depend on body of
the message being processed will be available. After processing, the message header is sent and
the platform starts to transfer message body, if any (with also processing by chunks processing
plugins). In cases when some plugin constructs response during this processing, no data is sent
to the destination web resource, but proxy reads and caches all incoming data of the request body,
if any, runs request late processing and then starts the process of handling of constructed
response as if it was received by the web resource.
<p>
When some plugin wants to modify message body, after the message header is received the
platform starts to cache incoming message body data (with also processing by chunks processing
plugins). After all message data has been received and cached, it runs this real-time processing,
during which plugins can read and / or modify both header and body content (through services).
After processing, the message si late processed and then it's header is sent followed by message
body data.
<p>
<u>Late message processing</u> is run every time after all data of the message that was sent or
will be sent is available.
<p>
To simplify the realization of plugins, that are interested in processing original messages
(as received from the client or web resource) or messages that were actually sent, late processing
is also run every time. It's run in time when all data of both original message and actual
message that was sent is available. During late processing only read only representation of a
HTTP message is passed to full message processing plugins as they are not expected / allowed to
modify it in any way.
<p>
<b>Desired services discovery</b><br>
The decision whether there will be whole message body accessible during real-time processing
(thus if there will be slowdown in message handling), is made by asking all plugins, if any one
wishes to modify the message, based on received HTTP header of the message. This is recognized
as need of 2 base content modifying services, <code>ModifiableBytesService</code> and
<code>ModifiableStringService</code> (see {@link sk.fiit.peweproxy.services.content}).
<p>
When a HTTP header for incoming request / response message is received (before any
message body data is read), AdaptiveProxy platform requests every full request / response
processing plugin to return a list of services (their definitions, i.e. interfaces of
those services) it would like to be able to use later in the processing phase. If it
finds one of these 2 services in the lists, there is a plugins that wants to modify the
message body, so that whole body has to be available during real-time processing.
<p>
If these base services are not find in the lists, platform then checks whether these services
aren't "desired indirectly". This is when a plugin (processing plugin or a module), in order
to do what it is made for, wants to be able to use some other service, which could be in turn
provided by plugged-in module if it could use one of these 2 base services, even "indirectly".
If one of these 2 services is "desired indirectly", there is a plugins that wants to modify
the message, so that whole body has to be available during real-time processing.
<p>
<b>Processes execution</b><br>
When a request / response HTTP message is real-time processed by the AdaptiveProxy platform,
a representation of the HTTP message is passed sequentially (configurable order) to all
successfully loaded request / response processing plugins (see
{@link sk.fiit.peweproxy.plugins.processing.RequestProcessingPlugin#processRequest(ModifiableHttpRequest)} and
{@link sk.fiit.peweproxy.plugins.processing.ResponseProcessingPlugin#processResponse(ModifiableHttpResponse)}).
Each processing plugin can read from the message or modify the message (what's available of it,
either a header only or also a body) and decide what's the next step in the message handling
process. Either it let the same message representation to be used in subsequent processing or
it provides substitutive message. At the same time it decides whether the message should be
passed for processing to the rest of the processing plugins, or it is a final message and
should be sent right away. Request processing plugins can also provide responses (which quits
request processing sequence) and decide whether they should be processed by loaded response
processing plugins or are final and should be sent right away. For detailed information on
how a processing plugin signals platform how to continue in message process handling, see
{@link sk.fiit.peweproxy.plugins.processing.RequestProcessingPlugin.RequestProcessingActions}
for request processing plugins and
{@link sk.fiit.peweproxy.plugins.processing.ResponseProcessingPlugin.ResponseProcessingActions}
for response processing plugins.
<p>
When a request / response HTTP message is late processed by the AdaptiveProxy platform, a
read-only representation of the HTTP message is passed sequentially (same order as above) to
all successfully loaded request / response processing plugins (see
{@link sk.fiit.peweproxy.plugins.processing.RequestProcessingPlugin#processTransferedRequest(HttpRequest)} and
{@link sk.fiit.peweproxy.plugins.processing.ResponseProcessingPlugin#processTransferedResponse(HttpResponse)}).
<h3><i>Message chunks processing</i></h3>
<b>Chunks processing</b><br>
In case of plugin that doesn't need to alter message according to whole message body content, but
only need to modify certain part of the message body (e.g. append some text, or replace some
text in specific part of the page), there's no need to cache the whole message body first, what
slows down message handling significantly. In those cases, plugin only need to be allowed to
modify parts or chunks of the message body as they are read from the connection with the source
of the message. This way, the handling time of the message is only increased by the time it
takes the plugins to process all chunks of transfered message body.
<p>
As stated above, data of the bodies of HTTP messages being proxied is also transfered through the
proxy server in chunks. The most basic way in which message body (carried within the message) is
delimited from following bytes of subsequent messages sent through the connection, is by
specifying message body length explicitly in the message header. In communication of HTTP/1.1
compliant hosts on the Internet however, bodies of the HTTP messages could also be and often are
self-delimited by using using specific transfer method (e.g. "chunked" transfer encoding, using 
boundary for multipart data types or by termination of connection, for more details see
<a href="http://tools.ietf.org/html/rfc2616#section-4.4"> RFC 2616: 4.4 Message Length</a>,
). When such method is used, there's no need to explicitly specify message body length in the
message header, and the possibility to alter data of the message body by the AdaptiveProxy
platform after it has already sent message header becomes available.
<p>
When the AdaptiveProxy platform can modify the message body without corrupting it (i.e.
introducing inconsistency of length specified in header and actual length), it will call loaded
message chunks processing plugins to process the chunks of the body of message being transfered,
so that they can change the chunk. Like in case of full message processing, message chunks
processing plugins can modify the content of the chunks through services provided by chunk
service modules.
<p>
<b>Desired services discovery</b><br>
Querying all message chunks processing plugins for desired services is done by AdaptiveProxy
platform in cases, when the body of the message is not self-delimiting (so that modification of
the message's body without altering it's header first would corrupt the message) and the target
of the message would able to handle self-delimited message. It's done to find out whether some
chunks plugin wants to be able to modify chunks being transfered so that the platform can change
the header sent before chunk processing accordingly.
<p>
<b>Processes execution</b><br>
When there is a possibility to modify chunks of the message body, chunk processing sequence
will be executed. First, before the header of the message is sent to it's target, chunk
processing is initiated (see
{@link sk.fiit.peweproxy.plugins.processing.RequestChunksProcessingPlugin#startRequestProcessing(ModifiableHttpRequest)} or 
{@link sk.fiit.peweproxy.plugins.processing.ResponseChunksProcessingPlugin#startResponseProcessing(ModifiableHttpResponse)})
on every successfully loaded and enabled chunk processing plugin so that they can modify the
header to their need.
<p>
Then, after the header is sent, platform starts to receive message body chunks and let enabled
chunk processing plugins to process it (see 
{@link sk.fiit.peweproxy.plugins.processing.RequestChunksProcessingPlugin#processRequestChunk(HttpRequest, ChunkServicesHandle)} or 
{@link sk.fiit.peweproxy.plugins.processing.ResponseChunksProcessingPlugin#processResponseChunk(HttpResponse, ChunkServicesHandle)})
for every received chunk. Plugins may take advantage of passed
{@link sk.fiit.peweproxy.services.ChunkServicesHandle} being an
{@link sk.fiit.peweproxy.services.DataHolder} to cease any underlying content that is the
beginning of what would be recognized as abstract content entity if not splitted into multiple
chunks. Before every call to <i>processChunk</i> method, content ceased in processing of previous
chunk (if any) is prepended to the data of the new chunk forming larger chunk that is in turn
processed.
<p>
After the proxy received and processed the last chunk of message's body, chunk processing is
ended (see
{@link sk.fiit.peweproxy.plugins.processing.RequestChunksProcessingPlugin#finalizeRequestProcessing(HttpRequest, ChunkServicesHandle)} or 
{@link sk.fiit.peweproxy.plugins.processing.ResponseChunksProcessingPlugin#finalizeResponseProcessing(HttpResponse, ChunkServicesHandle)})
on every enabled chunk processing plugin.
</body>
<address>
<a href="mailto:redeemer.sko@gmail.com">Jozef Tomek</a>
</address>
</html>
